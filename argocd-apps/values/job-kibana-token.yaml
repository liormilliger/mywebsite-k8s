# apiVersion: batch/v1
# kind: Job
# metadata:
#   name: kibana-token-creator
#   namespace: logging
#   annotations:
#     # This tells ArgoCD to run this manifest as a hook
#     argocd.argoproj.io/hook: Sync
#     # This tells ArgoCD to delete the Job once it completes successfully
#     argocd.argoproj.io/hook-delete-policy: HookSucceeded
# spec:
#   template:
#     spec:
#       serviceAccountName: kibana-token-creator-sa
#       restartPolicy: OnFailure
#       containers:
#       - name: token-creator
#         image: bitnami/kubectl:latest # A lightweight image with kubectl
#         command:
#         - "/bin/sh"
#         - "-c"
#         - |
#           set -e
#           set -o pipefail
#           echo "Checking if Kibana token secret already exists..."
#           if kubectl get secret kibana-es-token -n logging > /dev/null 2>&1; then
#             echo "Secret 'kibana-es-token' already exists. Nothing to do."
#             exit 0
#           fi
          
#           echo "Waiting for Elasticsearch pod to be ready..."
#           kubectl wait --for=condition=ready pod -l app=elasticsearch-master -n logging --timeout=300s
          
#           ES_POD=$(kubectl get pod -l app=elasticsearch-master -n logging -o jsonpath='{.items[0].metadata.name}')
#           echo "Found Elasticsearch pod: $ES_POD"
          
#           echo "Generating Kibana service token..."
#           TOKEN=$(kubectl exec -n logging $ES_POD -- \
#             /usr/share/elasticsearch/bin/elasticsearch-service-tokens create elastic/kibana kibana-token | \
#             grep "SERVICE_TOKEN =" | awk '{print $3}')
            
#           if [ -z "$TOKEN" ]; then
#             echo "Failed to generate token."
#             exit 1
#           fi
          
#           echo "Creating Kubernetes secret 'kibana-es-token'..."
#           kubectl create secret generic kibana-es-token -n logging --from-literal=token="$TOKEN"
#           echo "Secret created successfully."